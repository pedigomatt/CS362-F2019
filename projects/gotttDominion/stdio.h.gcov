        -:    0:Source:c:/mingw/include/stdio.h
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * stdio.h
        -:    3: *
        -:    4: * Definitions of types and prototypes of functions for operations on
        -:    5: * standard input and standard output streams.
        -:    6: *
        -:    7: * $Id: stdio.h,v 45c964eb9184 2019/07/03 20:49:42 keith $
        -:    8: *
        -:    9: * Written by Colin Peters <colin@bird.fu.is.saga-u.ac.jp>
        -:   10: * Copyright (C) 1997-2005, 2007-2010, 2014-2019, MinGW.org Project.
        -:   11: *
        -:   12: *
        -:   13: * Permission is hereby granted, free of charge, to any person obtaining a
        -:   14: * copy of this software and associated documentation files (the "Software"),
        -:   15: * to deal in the Software without restriction, including without limitation
        -:   16: * the rights to use, copy, modify, merge, publish, distribute, sublicense,
        -:   17: * and/or sell copies of the Software, and to permit persons to whom the
        -:   18: * Software is furnished to do so, subject to the following conditions:
        -:   19: *
        -:   20: * The above copyright notice, this permission notice, and the following
        -:   21: * disclaimer shall be included in all copies or substantial portions of
        -:   22: * the Software.
        -:   23: *
        -:   24: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        -:   25: * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   26: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
        -:   27: * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   28: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        -:   29: * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OF OR OTHER
        -:   30: * DEALINGS IN THE SOFTWARE.
        -:   31: *
        -:   32: * NOTE: The file manipulation functions provided by Microsoft seem to
        -:   33: * work with either slash (/) or backslash (\) as the directory separator;
        -:   34: * (this is consistent with Microsoft's own documentation, on MSDN).
        -:   35: *
        -:   36: */
        -:   37:#ifndef _STDIO_H
        -:   38:#pragma GCC system_header
        -:   39:
        -:   40:/* When including <wchar.h>, some of the definitions and declarations
        -:   41: * which are nominally provided in <stdio.h> must be duplicated.  Rather
        -:   42: * than require duplicated maintenance effort, we provide for partial
        -:   43: * inclusion of <stdio.h> by <wchar.h>; only when not included in
        -:   44: * this partial fashion...
        -:   45: */
        -:   46:#ifndef __WCHAR_H_SOURCED__
        -:   47: /* ...which is exclusive to <wchar.h>, do we assert the multiple
        -:   48:  * inclusion guard for <stdio.h> itself.
        -:   49:  */
        -:   50:#define _STDIO_H
        -:   51:#endif
        -:   52:
        -:   53:/* All the headers include this file.
        -:   54: */
        -:   55:#include <_mingw.h>
        -:   56:
        -:   57:#ifndef RC_INVOKED
        -:   58:/* POSIX stipulates that the following set of types, (as identified by
        -:   59: * __need_TYPENAME macros), shall be defined consistently with <stddef.h>;
        -:   60: * by defining the appropriate __need_TYPENAME macros, we may selectively
        -:   61: * obtain the required definitions by inclusion of <stddef.h>, WITHOUT
        -:   62: * automatic exposure of any of its additional content.
        -:   63: */
        -:   64:#define __need_NULL
        -:   65:#define __need_size_t
        -:   66:#define __need_wchar_t
        -:   67:#define __need_wint_t
        -:   68:#include <stddef.h>
        -:   69:
        -:   70:#if _POSIX_C_SOURCE >= 200809L
        -:   71: /* Similarly, for types defined in <sys/types.h>, (which are explicitly
        -:   72:  * dependent on the POSIX.1-2008 feature test)...
        -:   73:  */
        -:   74:# define __need_off_t
        -:   75:# define __need_ssize_t
        -:   76:#endif
        -:   77:
        -:   78:/* Although non-standard themselves, we also need either one or other
        -:   79: * of the following pair of data types, from <sys/types.h>, because our
        -:   80: * standard fpos_t is opaquely defined in terms of...
        -:   81: */
        -:   82:#ifdef __MSVCRT__
        -:   83: /* ...an explicitly 64-bit file offset type, for MSVCRT.DLL users...
        -:   84:  */
        -:   85:# define __need___off64_t
        -:   86:#else
        -:   87: /* ...or a 32-bit equivalent, for pre-MSVCRT.DLL users.
        -:   88:  */
        -:   89:# define __need___off32_t
        -:   90:#endif
        -:   91:
        -:   92:/* Note the use of the #include "..." form here, to ensure that we get
        -:   93: * the correct header file, relative to the location of this <stdio.h>
        -:   94: */
        -:   95:#include "sys/types.h"
        -:   96:
        -:   97:#ifndef __VALIST
        -:   98: /* Also similarly, for the va_list type, defined in "stdarg.h"
        -:   99:  */
        -:  100:# if defined __GNUC__ && __GNUC__ >= 3
        -:  101:#  define __need___va_list
        -:  102:#  include "stdarg.h"
        -:  103:#  define __VALIST __builtin_va_list
        -:  104:# else
        -:  105:#  define __VALIST char *
        -:  106:# endif
        -:  107:#endif
        -:  108:#endif	/* ! RC_INVOKED */
        -:  109:
        -:  110:#ifdef _STDIO_H
        -:  111:/* Flags for the iobuf structure
        -:  112: */
        -:  113:#define _IOREAD 	1	/* currently reading */
        -:  114:#define _IOWRT		2	/* currently writing */
        -:  115:#define _IORW	   0x0080	/* opened as "r+w" */
        -:  116:
        -:  117:/* The three standard file pointers provided by the run time library.
        -:  118: * NOTE: These will go to the bit-bucket silently in GUI applications!
        -:  119: */
        -:  120:#define STDIN_FILENO	0
        -:  121:#define STDOUT_FILENO	1
        -:  122:#define STDERR_FILENO	2
        -:  123:
        -:  124:/* Returned by various functions on end of file condition or error.
        -:  125: */
        -:  126:#define EOF	      (-1)
        -:  127:
        -:  128:#endif	/* _STDIO_H */
        -:  129:
        -:  130:/* The maximum length of a file name.  It may be better to use the Windows'
        -:  131: * GetVolumeInformation() function in preference to this constant, but hey,
        -:  132: * this works!  Note that <io.h> also defines it, but we don't guard it, so
        -:  133: * that the compiler has a chance to catch inconsistencies.
        -:  134: *
        -:  135: * FIXME: Right now, we define this unconditionally for both full <stdio.h>
        -:  136: * inclusion, and for partial inclusion on behalf of <wchar.h>, (which needs
        -:  137: * it for some non-ANSI structure declarations).  The conditions under which
        -:  138: * <wchar.h> needs this require review, because defining it as a consequence
        -:  139: * of including <wchar.h> alone may violate strict ANSI conformity.
        -:  140: */
        -:  141:#define FILENAME_MAX  (260)
        -:  142:
        -:  143:#ifdef _STDIO_H
        -:  144:/* The maximum number of files that may be open at once. I have set this to
        -:  145: * a conservative number. The actual value may be higher.
        -:  146: */
        -:  147:#define FOPEN_MAX      (20)
        -:  148:
        -:  149:/* After creating this many names, tmpnam and tmpfile return NULL
        -:  150: */
        -:  151:#define TMP_MAX      32767
        -:  152:
        -:  153:/* Tmpnam, tmpfile and, sometimes, _tempnam try to create
        -:  154: * temp files in the root directory of the current drive
        -:  155: * (not in pwd, as suggested by some older MS doc's).
        -:  156: * Redefining these macros does not effect the CRT functions.
        -:  157: */
        -:  158:#define _P_tmpdir   "\\"
        -:  159:#ifndef __STRICT_ANSI__
        -:  160:#define P_tmpdir _P_tmpdir
        -:  161:#endif
        -:  162:#define _wP_tmpdir  L"\\"
        -:  163:
        -:  164:/* The maximum size of name (including NUL) that will be put in the user
        -:  165: * supplied buffer caName for tmpnam.
        -:  166: * Inferred from the size of the static buffer returned by tmpnam
        -:  167: * when passed a NULL argument. May actually be smaller.
        -:  168: */
        -:  169:#define L_tmpnam (16)
        -:  170:
        -:  171:#define _IOFBF		0x0000	/* full buffered */
        -:  172:#define _IOLBF		0x0040	/* line buffered */
        -:  173:#define _IONBF		0x0004	/* not buffered */
        -:  174:
        -:  175:#define _IOMYBUF	0x0008	/* stdio malloc()'d buffer */
        -:  176:#define _IOEOF		0x0010	/* EOF reached on read */
        -:  177:#define _IOERR		0x0020	/* I/O error from system */
        -:  178:#define _IOSTRG 	0x0040	/* Strange or no file descriptor */
        -:  179:#ifdef _POSIX_SOURCE
        -:  180:# define _IOAPPEND	0x0200
        -:  181:#endif
        -:  182:
        -:  183:/* The buffer size as used by setbuf such that it is equivalent to
        -:  184: * (void) setvbuf(fileSetBuffer, caBuffer, _IOFBF, BUFSIZ).
        -:  185: */
        -:  186:#define BUFSIZ		   512
        -:  187:
        -:  188:/* Constants for nOrigin indicating the position relative to which fseek
        -:  189: * sets the file position.  Defined unconditionally since ISO and POSIX
        -:  190: * say they are defined here.
        -:  191: */
        -:  192:#define SEEK_SET	     0
        -:  193:#define SEEK_CUR	     1
        -:  194:#define SEEK_END	     2
        -:  195:
        -:  196:#endif	/* _STDIO_H */
        -:  197:
        -:  198:#ifndef RC_INVOKED
        -:  199:#if ! (defined _STDIO_H && defined _WCHAR_H)
        -:  200:/* The structure underlying the FILE type; this should be defined when
        -:  201: * including either <stdio.h> or <wchar.h>.  If both header include guards
        -:  202: * are now in place, then we must currently be including <stdio.h> in its
        -:  203: * own right, having already processed this block during a prior partial
        -:  204: * inclusion by <wchar.h>; there is no need to process it a second time.
        -:  205: *
        -:  206: * Some believe that nobody in their right mind should make use of the
        -:  207: * internals of this structure. Provided by Pedro A. Aranda Gutiirrez
        -:  208: * <paag@tid.es>.
        -:  209: */
        -:  210:typedef struct _iobuf
        -:  211:{
        -:  212:  char	*_ptr;
        -:  213:  int	 _cnt;
        -:  214:  char	*_base;
        -:  215:  int	 _flag;
        -:  216:  int	 _file;
        -:  217:  int	 _charbuf;
        -:  218:  int	 _bufsiz;
        -:  219:  char	*_tmpfname;
        -:  220:} FILE;
        -:  221:
        -:  222:#endif  /* ! (_STDIO_H && _WCHAR_H) */
        -:  223:#ifdef _STDIO_H
        -:  224:/* Content to be exposed only when including <stdio.h> in its own right;
        -:  225: * these will not be exposed when __WCHAR_H_SOURCE__ is defined, as will
        -:  226: * be the case when <stdio.h> is included indirectly, by <wchar.h>
        -:  227: *
        -:  228: *
        -:  229: * The standard file handles
        -:  230: */
        -:  231:#ifndef __DECLSPEC_SUPPORTED
        -:  232:
        -:  233:extern FILE (*_imp___iob)[];	/* A pointer to an array of FILE */
        -:  234:
        -:  235:#define _iob (*_imp___iob)	/* An array of FILE */
        -:  236:
        -:  237:#else /* __DECLSPEC_SUPPORTED */
        -:  238:
        -:  239:__MINGW_IMPORT FILE _iob[];	/* An array of FILE imported from DLL. */
        -:  240:
        -:  241:#endif /* __DECLSPEC_SUPPORTED */
        -:  242:
        -:  243:#define stdin	(&_iob[STDIN_FILENO])
        -:  244:#define stdout	(&_iob[STDOUT_FILENO])
        -:  245:#define stderr	(&_iob[STDERR_FILENO])
        -:  246:
        -:  247:/* Need to close the current _STDIO_H specific block here...
        -:  248: */
        -:  249:#endif
        -:  250:/* ...because, we need this regardless of the inclusion mode...
        -:  251: */
        -:  252:_BEGIN_C_DECLS
        -:  253:
        -:  254:#ifdef _STDIO_H
        -:  255:/* ...then revert to _STDIO_H specific mode, to declare...
        -:  256: *
        -:  257: *
        -:  258: * File Operations
        -:  259: */
        -:  260:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * fopen (const char *, const char *);
        -:  261:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * freopen (const char *, const char *, FILE *);
        -:  262:_CRTIMP __cdecl __MINGW_NOTHROW  int    fflush (FILE *);
        -:  263:_CRTIMP __cdecl __MINGW_NOTHROW  int    fclose (FILE *);
        -:  264:
        -:  265:/* Note: Microsoft also declares remove & rename (but not their wide char
        -:  266: * variants) in <io.h>; since duplicate prototypes are acceptable, provided
        -:  267: * they are consistent, we simply declare them here anyway, while allowing
        -:  268: * the compiler to check consistency as appropriate.
        -:  269: */
        -:  270:_CRTIMP __cdecl __MINGW_NOTHROW  int    remove (const char *);
        -:  271:_CRTIMP __cdecl __MINGW_NOTHROW  int    rename (const char *, const char *);
        -:  272:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * tmpfile (void);
        -:  273:_CRTIMP __cdecl __MINGW_NOTHROW  char * tmpnam (char *);
        -:  274:
        -:  275:#ifndef __STRICT_ANSI__
        -:  276:_CRTIMP __cdecl __MINGW_NOTHROW  char *_tempnam (const char *, const char *);
        -:  277:_CRTIMP __cdecl __MINGW_NOTHROW  int   _rmtmp (void);
        -:  278:_CRTIMP __cdecl __MINGW_NOTHROW  int   _unlink (const char *);
        -:  279:
        -:  280:#if __MSVCRT_VERSION__>=__MSVCR80_DLL
        -:  281:/* The following pair of non-ANSI functions require a non-free version of
        -:  282: * the Microsoft runtime; neither is provided by any MSVCRT.DLL variant.
        -:  283: */
        -:  284:_CRTIMP __cdecl __MINGW_NOTHROW  void  _lock_file(FILE *);
        -:  285:_CRTIMP __cdecl __MINGW_NOTHROW  void  _unlock_file(FILE *);
        -:  286:#endif
        -:  287:
        -:  288:#ifndef NO_OLDNAMES
        -:  289:_CRTIMP __cdecl __MINGW_NOTHROW  char * tempnam (const char *, const char *);
        -:  290:_CRTIMP __cdecl __MINGW_NOTHROW  int    rmtmp (void);
        -:  291:_CRTIMP __cdecl __MINGW_NOTHROW  int    unlink (const char *);
        -:  292:#endif
        -:  293:#endif /* __STRICT_ANSI__ */
        -:  294:
        -:  295:_CRTIMP __cdecl __MINGW_NOTHROW  int    setvbuf (FILE *, char *, int, size_t);
        -:  296:_CRTIMP __cdecl __MINGW_NOTHROW  void   setbuf (FILE *, char *);
        -:  297:
        -:  298:/* Formatted Output
        -:  299: *
        -:  300: * MSVCRT implementations are not ANSI C99 conformant...
        -:  301: * we offer conforming alternatives from libmingwex.a
        -:  302: */
        -:  303:#undef  __mingw_stdio_redirect__
        -:  304:#define __mingw_stdio_redirect__(F) __cdecl __MINGW_NOTHROW __Wformat(F)
        -:  305:#define __Wformat_mingw_printf(F,A) __attribute__((__format__(__mingw_printf__,F,A)))
        -:  306:
        -:  307:#if __GNUC__ >= 6
        -:  308:/* From GCC-6 onwards, we will provide customized -Wformat
        -:  309: * handling, via our own mingw_printf format category...
        -:  310: */
        -:  311:#define __Wformat(F)		__Wformat_##F __mingw_##F
        -:  312:
        -:  313:#else	/* __GNUC__ < 6 */
        -:  314:/* ...whereas, for earlier GCC, we preserve the status quo,
        -:  315: * offering no -Wformat checking for those functions which
        -:  316: * replace the MSVCRT.DLL versions...
        -:  317: */
        -:  318:#define __Wformat(F)		__mingw_##F
        -:  319:
        -:  320:/* ...while degrading to gnu_printf checking for snprintf()
        -:  321: * and vsnprintf(), (which are ALWAYS MinGW.org variants).
        -:  322: */
        -:  323:#define __mingw_printf__	__gnu_printf__
        -:  324:#endif
        -:  325:
        -:  326:/* The following convenience macros specify the appropriate
        -:  327: * -Wformat checking for MSVCRT.DLL replacement functions...
        -:  328: */
        -:  329:#define __Wformat_printf	__Wformat_mingw_printf(1,2)
        -:  330:#define __Wformat_fprintf	__Wformat_mingw_printf(2,3)
        -:  331:#define __Wformat_sprintf	__Wformat_mingw_printf(2,3)
        -:  332:#define __Wformat_vprintf	__Wformat_mingw_printf(1,0)
        -:  333:#define __Wformat_vfprintf	__Wformat_mingw_printf(2,0)
        -:  334:#define __Wformat_vsprintf	__Wformat_mingw_printf(2,0)
        -:  335:
        -:  336:/* ...while this pair are specific to the two MinGW.org
        -:  337: * only functions.
        -:  338: */
        -:  339:#define __Wformat_snprintf	__Wformat_mingw_printf(3,4)
        -:  340:#define __Wformat_vsnprintf	__Wformat_mingw_printf(3,0)
        -:  341:
        -:  342:extern int __mingw_stdio_redirect__(fprintf)(FILE*, const char*, ...);
        -:  343:extern int __mingw_stdio_redirect__(printf)(const char*, ...);
        -:  344:extern int __mingw_stdio_redirect__(sprintf)(char*, const char*, ...);
        -:  345:extern int __mingw_stdio_redirect__(snprintf)(char*, size_t, const char*, ...);
        -:  346:extern int __mingw_stdio_redirect__(vfprintf)(FILE*, const char*, __VALIST);
        -:  347:extern int __mingw_stdio_redirect__(vprintf)(const char*, __VALIST);
        -:  348:extern int __mingw_stdio_redirect__(vsprintf)(char*, const char*, __VALIST);
        -:  349:extern int __mingw_stdio_redirect__(vsnprintf)(char*, size_t, const char*, __VALIST);
        -:  350:
        -:  351:/* When using these C99 conforming alternatives, we may wish to support
        -:  352: * some of Microsoft's quirky formatting options, even when they violate
        -:  353: * strict C99 conformance.
        -:  354: */
        -:  355:#define _MSVC_PRINTF_QUIRKS		0x0100U
        -:  356:#define _QUERY_MSVC_PRINTF_QUIRKS	~0U, 0U
        -:  357:#define _DISABLE_MSVC_PRINTF_QUIRKS	~_MSVC_PRINTF_QUIRKS, 0U
        -:  358:#define _ENABLE_MSVC_PRINTF_QUIRKS	~0U, _MSVC_PRINTF_QUIRKS
        -:  359:
        -:  360:/* Those quirks which conflict with ANSI C99 specified behaviour are
        -:  361: * disabled by default; use the following function, like this:
        -:  362: *
        -:  363: *   _mingw_output_format_control( _ENABLE_MSVC_PRINTF_QUIRKS );
        -:  364: *
        -:  365: * to enable them, like this:
        -:  366: *
        -:  367: *   state = _mingw_output_format_control( _QUERY_MSVC_PRINTF_QUIRKS )
        -:  368: *		& _MSVC_PRINTF_QUIRKS;
        -:  369: *
        -:  370: * to ascertain the currently active enabled state, or like this:
        -:  371: *
        -:  372: *   _mingw_output_format_control( _DISABLE_MSVC_PRINTF_QUIRKS );
        -:  373: *
        -:  374: * to disable them again.
        -:  375: */
        -:  376:extern unsigned int _mingw_output_format_control( unsigned int, unsigned int );
        -:  377:
        -:  378:#if __USE_MINGW_ANSI_STDIO || defined _ISOC99_SOURCE
        -:  379:/* User has expressed a preference for C99 conformance...
        -:  380: */
        -:  381:# undef __mingw_stdio_redirect__
        -:  382:# ifdef __cplusplus
        -:  383:/* For C++ we use inline implementations, to avoid interference
        -:  384: * with namespace qualification, which may result from using #defines.
        -:  385: */
        -:  386:#  define __mingw_stdio_redirect__  inline __cdecl __MINGW_NOTHROW
        -:  387:
        -:  388:# elif defined __GNUC__
        -:  389:/* FIXME: Is there any GCC version prerequisite here?
        -:  390: *
        -:  391: * We also prefer inline implementations for C, when we can be confident
        -:  392: * that the GNU specific __inline__ mechanism is supported.
        -:  393: */
        -:  394:#  define __mingw_stdio_redirect__  static __inline__ __cdecl __MINGW_NOTHROW
        -:  395:
        -:  396:# else	/* Neither C++ nor __GNUC__ */
        -:  397:/* Can't use inlines; fall back on module local static stubs.
        -:  398: */
        -:  399:#  define __mingw_stdio_redirect__  static __cdecl __MINGW_NOTHROW
        -:  400:
        -:  401:# endif	/* Neither C++ nor __GNUC__ */
        -:  402:#endif	/* __USE_MINGW_ANSI_STDIO || defined _ISOC99_SOURCE */
        -:  403:
        -:  404:#if __USE_MINGW_ANSI_STDIO
        -:  405:/* The MinGW ISO-C conforming implementations of the printf() family
        -:  406: * of functions are to be used, in place of non-conforming Microsoft
        -:  407: * implementations; force call redirection, via the following set of
        -:  408: * in-line functions.
        -:  409: */
        -:  410:__mingw_stdio_redirect__
        -:  411:int fprintf (FILE *__stream, const char *__format, ...)
        -:  412:{
        -:  413:  register int __retval;
        -:  414:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
        -:  415:  __retval = __mingw_vfprintf( __stream, __format, __local_argv );
        -:  416:  __builtin_va_end( __local_argv );
        -:  417:  return __retval;
        -:  418:}
        -:  419:
        -:  420:__mingw_stdio_redirect__
function printf called 0 returned 0% blocks executed 0%
    #####:  421:int printf (const char *__format, ...)
        -:  422:{
        -:  423:  register int __retval;
    #####:  424:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
    #####:  425:  __retval = __mingw_vprintf( __format, __local_argv );
call    0 never executed
    #####:  426:  __builtin_va_end( __local_argv );
    #####:  427:  return __retval;
        -:  428:}
        -:  429:
        -:  430:__mingw_stdio_redirect__
        -:  431:int sprintf (char *__stream, const char *__format, ...)
        -:  432:{
        -:  433:  register int __retval;
        -:  434:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
        -:  435:  __retval = __mingw_vsprintf( __stream, __format, __local_argv );
        -:  436:  __builtin_va_end( __local_argv );
        -:  437:  return __retval;
        -:  438:}
        -:  439:
        -:  440:__mingw_stdio_redirect__
        -:  441:int vfprintf (FILE *__stream, const char *__format, __VALIST __local_argv)
        -:  442:{
        -:  443:  return __mingw_vfprintf( __stream, __format, __local_argv );
        -:  444:}
        -:  445:
        -:  446:__mingw_stdio_redirect__
        -:  447:int vprintf (const char *__format, __VALIST __local_argv)
        -:  448:{
        -:  449:  return __mingw_vprintf( __format, __local_argv );
        -:  450:}
        -:  451:
        -:  452:__mingw_stdio_redirect__
        -:  453:int vsprintf (char *__stream, const char *__format, __VALIST __local_argv)
        -:  454:{
        -:  455:  return __mingw_vsprintf( __stream, __format, __local_argv );
        -:  456:}
        -:  457:
        -:  458:#else	/* !__USE_MINGW_ANSI_STDIO */
        -:  459:/* Default configuration: simply direct all calls to MSVCRT...
        -:  460: */
        -:  461:_CRTIMP __cdecl __MINGW_NOTHROW  int fprintf (FILE *, const char *, ...);
        -:  462:_CRTIMP __cdecl __MINGW_NOTHROW  int printf (const char *, ...);
        -:  463:_CRTIMP __cdecl __MINGW_NOTHROW  int sprintf (char *, const char *, ...);
        -:  464:_CRTIMP __cdecl __MINGW_NOTHROW  int vfprintf (FILE *, const char *, __VALIST);
        -:  465:_CRTIMP __cdecl __MINGW_NOTHROW  int vprintf (const char *, __VALIST);
        -:  466:_CRTIMP __cdecl __MINGW_NOTHROW  int vsprintf (char *, const char *, __VALIST);
        -:  467:
        -:  468:#endif	/* !__USE_MINGW_ANSI_STDIO */
        -:  469:
        -:  470:#if __GNUC__ && defined _ISOC99_SOURCE
        -:  471:/* Although MinGW implementations of the ISO-C99 snprintf() and
        -:  472: * vsnprintf() functions do not conflict with any implementation
        -:  473: * in MSVCRT.DLL, (because MSVCRT.DLL does not implement either),
        -:  474: * there are -Wformat attribute conflicts with the GCC built-in
        -:  475: * prototypes associated with each; by providing the following
        -:  476: * in-line function implementations, which will override GCC's
        -:  477: * built-in prototypes, we may avoid these conflicts.
        -:  478: */
        -:  479:__mingw_stdio_redirect__
        -:  480:int snprintf (char *__buf, size_t __len, const char *__format, ...)
        -:  481:{
        -:  482:  register int __retval;
        -:  483:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
        -:  484:  __retval = __mingw_vsnprintf( __buf, __len, __format, __local_argv );
        -:  485:  __builtin_va_end( __local_argv );
        -:  486:  return __retval;
        -:  487:}
        -:  488:
        -:  489:__mingw_stdio_redirect__
        -:  490:int vsnprintf (char *__buf, size_t __len, const char *__format, __VALIST __local_argv)
        -:  491:{
        -:  492:  return __mingw_vsnprintf( __buf, __len, __format, __local_argv );
        -:  493:}
        -:  494:#endif	/* __GNUC__ && defined _ISOC99_SOURCE */
        -:  495:
        -:  496:/* Regardless of user preference, always offer these alternative
        -:  497: * entry points, for direct access to the MSVCRT implementations,
        -:  498: * with ms_printf -Wformat checking in each case.
        -:  499: */
        -:  500:#undef  __Wformat
        -:  501:#undef  __mingw_stdio_redirect__
        -:  502:#define __mingw_stdio_redirect__(F) __cdecl __MINGW_NOTHROW __Wformat(F)
        -:  503:#define __Wformat_msvcrt_printf(F,A) __attribute__((__format__(__ms_printf__,F,A)))
        -:  504:#define __Wformat(F) __Wformat_ms_##F __msvcrt_##F
        -:  505:
        -:  506:#define __Wformat_ms_printf	__Wformat_msvcrt_printf(1,2)
        -:  507:#define __Wformat_ms_fprintf	__Wformat_msvcrt_printf(2,3)
        -:  508:#define __Wformat_ms_sprintf	__Wformat_msvcrt_printf(2,3)
        -:  509:#define __Wformat_ms_vprintf	__Wformat_msvcrt_printf(1,0)
        -:  510:#define __Wformat_ms_vfprintf	__Wformat_msvcrt_printf(2,0)
        -:  511:#define __Wformat_ms_vsprintf	__Wformat_msvcrt_printf(2,0)
        -:  512:
        -:  513:_CRTIMP int __mingw_stdio_redirect__(fprintf)(FILE *, const char *, ...);
        -:  514:_CRTIMP int __mingw_stdio_redirect__(printf)(const char *, ...);
        -:  515:_CRTIMP int __mingw_stdio_redirect__(sprintf)(char *, const char *, ...);
        -:  516:_CRTIMP int __mingw_stdio_redirect__(vfprintf)(FILE *, const char *, __VALIST);
        -:  517:_CRTIMP int __mingw_stdio_redirect__(vprintf)(const char *, __VALIST);
        -:  518:_CRTIMP int __mingw_stdio_redirect__(vsprintf)(char *, const char *, __VALIST);
        -:  519:
        -:  520:#undef  __mingw_stdio_redirect__
        -:  521:#undef  __Wformat
        -:  522:
        -:  523:/* The following three ALWAYS refer to the MSVCRT implementations...
        -:  524: */
        -:  525:_CRTIMP __cdecl __MINGW_NOTHROW  int _snprintf (char *, size_t, const char *, ...);
        -:  526:_CRTIMP __cdecl __MINGW_NOTHROW  int _vsnprintf (char *, size_t, const char *, __VALIST);
        -:  527:_CRTIMP __cdecl __MINGW_NOTHROW  int _vscprintf (const char *, __VALIST);
        -:  528:
        -:  529:#ifdef _ISOC99_SOURCE
        -:  530:/* Microsoft does not provide implementations for the following,
        -:  531: * which are required by C99.  Note in particular that Microsoft's
        -:  532: * corresponding implementations of _snprintf() and _vsnprintf() are
        -:  533: * NOT compatible with C99, but the following are; if you want the
        -:  534: * MSVCRT behaviour, you MUST use the Microsoft "uglified" names.
        -:  535: */
        -:  536:__cdecl __MINGW_NOTHROW __Wformat_snprintf
        -:  537:int snprintf (char *, size_t, const char *, ...);
        -:  538:
        -:  539:__cdecl __MINGW_NOTHROW __Wformat_vsnprintf
        -:  540:int vsnprintf (char *, size_t, const char *, __VALIST);
        -:  541:
        -:  542:__cdecl __MINGW_NOTHROW
        -:  543:int vscanf (const char * __restrict__, __VALIST);
        -:  544:
        -:  545:__cdecl __MINGW_NOTHROW
        -:  546:int vfscanf (FILE * __restrict__, const char * __restrict__, __VALIST);
        -:  547:
        -:  548:__cdecl __MINGW_NOTHROW
        -:  549:int vsscanf (const char * __restrict__, const char * __restrict__, __VALIST);
        -:  550:
        -:  551:#endif  /* _ISOC99_SOURCE */
        -:  552:#endif	/* <stdio.h> included in its own right */
        -:  553:
        -:  554:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL || _WIN32_WINNT >= _WIN32_WINNT_VISTA
        -:  555:/* In MSVCR80.DLL, (and its descendants), Microsoft introduced variants
        -:  556: * of the printf() functions, with names qualified by an underscore prefix
        -:  557: * and "_p" or "_p_l" suffixes; implemented in Microsoft's typically crass,
        -:  558: * non-standard, and non-portable fashion, these provide support for access
        -:  559: * to printf() arguments in random order, as was standardised by POSIX as a
        -:  560: * feature of the optional Extended Systems Interface (XSI) specification,
        -:  561: * and is now required for conformity with the POSIX.1-2008 base standard.
        -:  562: * Although these additional Microsoft functions were subsequently added
        -:  563: * to MSVCRT.DLL, from Windows-Vista onward, and they are prototyped here,
        -:  564: * MinGW applications are strenuously encouraged to avoid using them; a
        -:  565: * much better alternative is to "#define _XOPEN_SOURCE 700" before any
        -:  566: * system header is included, then use POSIX standard printf() functions
        -:  567: * instead; this is both portable to many non-Windows platforms, and it
        -:  568: * offers better compatibility with earlier Windows versions.
        -:  569: */
        -:  570:#ifndef __have_typedef_locale_t
        -:  571:/* Note that some of the following require the opaque locale_t data type,
        -:  572: * which we may obtain, by selective inclusion, from <locale.h>
        -:  573: */
        -:  574:#define __need_locale_t
        -:  575:#include <locale.h>
        -:  576:#endif
        -:  577:
        -:  578:#ifdef _STDIO_H
        -:  579:/* The following are to be declared only when <stdio.h> is explicitly
        -:  580: * included; the first six are NOT dependent on locale_t...
        -:  581: */
        -:  582:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  583:int _printf_p (const char *, ...);
        -:  584:
        -:  585:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  586:int _fprintf_p (FILE *, const char *, ...);
        -:  587:
        -:  588:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  589:int _sprintf_p (char *, size_t, const char *, ...);
        -:  590:
        -:  591:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  592:int _vprintf_p (const char *, __VALIST);
        -:  593:
        -:  594:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  595:int _vfprintf_p (FILE *, const char *, __VALIST);
        -:  596:
        -:  597:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  598:int _vsprintf_p (char *, size_t, const char *, __VALIST);
        -:  599:
        -:  600:/* ...whereas the following six DO depend on locale_t.
        -:  601: *
        -:  602: * CAVEAT: unless you are linking with non-free MSVCR80.DLL, or one
        -:  603: * of its later derivatives, good luck trying to use these; see the
        -:  604: * explanation in <locale.t>, as to why you may be unable to create,
        -:  605: * or otherwise acquire a reference to, a locale_t object.
        -:  606: */
        -:  607:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  608:int _printf_p_l (const char *, locale_t, ...);
        -:  609:
        -:  610:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  611:int _fprintf_p_l (FILE *, const char *, locale_t, ...);
        -:  612:
        -:  613:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  614:int _sprintf_p_l (char *, size_t, const char *, locale_t, ...);
        -:  615:
        -:  616:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  617:int _vprintf_p_l (const char *, locale_t, __VALIST);
        -:  618:
        -:  619:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  620:int _vfprintf_p_l (FILE *, const char *, locale_t, __VALIST);
        -:  621:
        -:  622:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  623:int _vsprintf_p_l (char *, size_t, const char *, locale_t, __VALIST);
        -:  624:
        -:  625:#endif	/* <stdio.h> included in its own right */
        -:  626:#endif	/* MSVCR80.DLL and descendants, or MSVCRT.DLL since Vista */
        -:  627:
        -:  628:#if ! (defined _STDIO_H && defined _WCHAR_H)
        -:  629:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL || _WIN32_WINNT >= _WIN32_WINNT_VISTA
        -:  630:/* Wide character variants of the foregoing "positional parameter" printf()
        -:  631: * functions; MSDN says that these should be declared when either <stdio.h>, or
        -:  632: * <wchar.h> is included, so we make them selectively available to <wchar.h>,
        -:  633: * but, just as in the foregoing, we advise against their use.
        -:  634: */
        -:  635:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  636:int _wprintf_p (const wchar_t *, ...);
        -:  637:
        -:  638:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  639:int _fwprintf_p (FILE *, const wchar_t *, ...);
        -:  640:
        -:  641:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  642:int _swprintf_p (wchar_t *, size_t, const wchar_t *, ...);
        -:  643:
        -:  644:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  645:int _vwprintf_p (const wchar_t *, __VALIST);
        -:  646:
        -:  647:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  648:int _vfwprintf_p (FILE *, const wchar_t *, __VALIST);
        -:  649:
        -:  650:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  651:int _vswprintf_p (wchar_t *, size_t, const wchar_t *, __VALIST);
        -:  652:
        -:  653:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  654:int _wprintf_p_l (const wchar_t *, locale_t, ...);
        -:  655:
        -:  656:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  657:int _fwprintf_p_l (FILE *, const wchar_t *, locale_t, ...);
        -:  658:
        -:  659:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  660:int _swprintf_p_l (wchar_t *, size_t, const wchar_t *, locale_t, ...);
        -:  661:
        -:  662:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  663:int _vwprintf_p_l (const wchar_t *, locale_t, __VALIST);
        -:  664:
        -:  665:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  666:int _vfwprintf_p_l (FILE *, const wchar_t *, locale_t, __VALIST);
        -:  667:
        -:  668:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  669:int _vswprintf_p_l (wchar_t *, size_t, const wchar_t *, locale_t, __VALIST);
        -:  670:
        -:  671:#endif	/* MSVCR80.DLL and descendants, or MSVCRT.DLL since Vista */
        -:  672:#endif	/* ! (defined _STDIO_H && defined _WCHAR_H) */
        -:  673:#ifdef _STDIO_H
        -:  674:/* Once again, back to <stdio.h> specific declarations.
        -:  675: */
        -:  676:#if _POSIX_C_SOURCE >= 200809L
        -:  677:/* POSIX standard IEEE 1003.1-2008 added getdelim() and getline()
        -:  678: */
        -:  679:__cdecl __MINGW_NOTHROW ssize_t
        -:  680:getdelim (char ** __restrict__, size_t * __restrict__, int, FILE * __restrict__);
        -:  681:
        -:  682:__cdecl __MINGW_NOTHROW ssize_t
        -:  683:getline (char ** __restrict__, size_t * __restrict__, FILE * __restrict__);
        -:  684:
        -:  685:#ifndef __NO_INLINE__
        -:  686:/* getline() is a trivial specialization of getdelim(), which may
        -:  687: * be readily expressed by inline expansion.
        -:  688: */
        -:  689:__CRT_ALIAS __LIBIMPL__(( FUNCTION = getline ))
        -:  690:__cdecl __MINGW_NOTHROW ssize_t getline
        -:  691:( char **__restrict__ __l, size_t *__restrict__ __n, FILE *__restrict__ __s )
        -:  692:{ return getdelim( __l, __n, '\n', __s ); }
        -:  693:
        -:  694:#endif  /* !__NO_INLINE__ */
        -:  695:#endif  /* POSIX.1-2008 */
        -:  696:
        -:  697:/* Formatted Input
        -:  698: */
        -:  699:_CRTIMP __cdecl __MINGW_NOTHROW  int    fscanf (FILE *, const char *, ...);
        -:  700:_CRTIMP __cdecl __MINGW_NOTHROW  int    scanf (const char *, ...);
        -:  701:_CRTIMP __cdecl __MINGW_NOTHROW  int    sscanf (const char *, const char *, ...);
        -:  702:
        -:  703:/* Character Input and Output Functions
        -:  704: */
        -:  705:_CRTIMP __cdecl __MINGW_NOTHROW  int    fgetc (FILE *);
        -:  706:_CRTIMP __cdecl __MINGW_NOTHROW  char * fgets (char *, int, FILE *);
        -:  707:_CRTIMP __cdecl __MINGW_NOTHROW  int    fputc (int, FILE *);
        -:  708:_CRTIMP __cdecl __MINGW_NOTHROW  int    fputs (const char *, FILE *);
        -:  709:_CRTIMP __cdecl __MINGW_NOTHROW  char * gets (char *);
        -:  710:_CRTIMP __cdecl __MINGW_NOTHROW  int    puts (const char *);
        -:  711:_CRTIMP __cdecl __MINGW_NOTHROW  int    ungetc (int, FILE *);
        -:  712:
        -:  713:/* Traditionally, getc and putc are defined as macros. but the
        -:  714: * standard doesn't say that they must be macros.  We use inline
        -:  715: * functions here to allow the fast versions to be used in C++
        -:  716: * with namespace qualification, eg., ::getc.
        -:  717: *
        -:  718: * NOTE: _filbuf and _flsbuf  are not thread-safe.
        -:  719: */
        -:  720:_CRTIMP __cdecl __MINGW_NOTHROW  int   _filbuf (FILE *);
        -:  721:_CRTIMP __cdecl __MINGW_NOTHROW  int   _flsbuf (int, FILE *);
        -:  722:
        -:  723:#if !defined _MT
        -:  724:
        -:  725:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getc (FILE *);
        -:  726:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getc (FILE * __F)
        -:  727:{
        -:  728:  return (--__F->_cnt >= 0)
        -:  729:    ?  (int) (unsigned char) *__F->_ptr++
        -:  730:    : _filbuf (__F);
        -:  731:}
        -:  732:
        -:  733:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putc (int, FILE *);
        -:  734:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putc (int __c, FILE * __F)
        -:  735:{
        -:  736:  return (--__F->_cnt >= 0)
        -:  737:    ?  (int) (unsigned char) (*__F->_ptr++ = (char)__c)
        -:  738:    :  _flsbuf (__c, __F);
        -:  739:}
        -:  740:
        -:  741:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getchar (void);
        -:  742:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getchar (void)
        -:  743:{
        -:  744:  return (--stdin->_cnt >= 0)
        -:  745:    ?  (int) (unsigned char) *stdin->_ptr++
        -:  746:    : _filbuf (stdin);
        -:  747:}
        -:  748:
        -:  749:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putchar(int);
        -:  750:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putchar(int __c)
        -:  751:{
        -:  752:  return (--stdout->_cnt >= 0)
        -:  753:    ?  (int) (unsigned char) (*stdout->_ptr++ = (char)__c)
        -:  754:    :  _flsbuf (__c, stdout);}
        -:  755:
        -:  756:#else  /* Use library functions.  */
        -:  757:
        -:  758:_CRTIMP __cdecl __MINGW_NOTHROW  int    getc (FILE *);
        -:  759:_CRTIMP __cdecl __MINGW_NOTHROW  int    putc (int, FILE *);
        -:  760:_CRTIMP __cdecl __MINGW_NOTHROW  int    getchar (void);
        -:  761:_CRTIMP __cdecl __MINGW_NOTHROW  int    putchar (int);
        -:  762:
        -:  763:#endif
        -:  764:
        -:  765:/* Direct Input and Output Functions
        -:  766: */
        -:  767:_CRTIMP __cdecl __MINGW_NOTHROW  size_t fread (void *, size_t, size_t, FILE *);
        -:  768:_CRTIMP __cdecl __MINGW_NOTHROW  size_t fwrite (const void *, size_t, size_t, FILE *);
        -:  769:
        -:  770:/* File Positioning Functions
        -:  771: */
        -:  772:_CRTIMP __cdecl __MINGW_NOTHROW  int    fseek (FILE *, long, int);
        -:  773:_CRTIMP __cdecl __MINGW_NOTHROW  long   ftell (FILE *);
        -:  774:_CRTIMP __cdecl __MINGW_NOTHROW  void   rewind (FILE *);
        -:  775:
        -:  776:#ifdef __USE_MINGW_FSEEK
        -:  777:/* Workaround for a limitation on Win9x where a file is not zero padded
        -:  778: * on write, following a seek beyond the original end of file; supporting
        -:  779: * redirector functions are implemented in libmingwex.a
        -:  780: *
        -:  781: * Note: this is improper usage.  __USE_MINGW_FSEEK exhibits the form of a
        -:  782: * private (system reserved) feature test macro; as such, users should not
        -:  783: * define it directly, and thus, it really should not have been defined at
        -:  784: * this point; discourage this practice.
        -:  785: */
        -:  786:#warning "The __USE_MINGW_FSEEK feature test is deprecated"
        -:  787:#pragma info "Define _WIN32_WINDOWS, instead of __USE_MINGW_FSEEK"
        -:  788:
        -:  789:#elif _WIN32_WINDOWS >= _WIN32_WINDOWS_95 && _WIN32_WINDOWS < _WIN32_WINNT_WIN2K
        -:  790:/* This is correct usage; the private __USE_MINGW_FSEEK feature affects only
        -:  791: * Win9x, so enable it implicitly when the _WIN32_WINDOWS feature is specified,
        -:  792: * thus indicating the user's intent to target a Win9x platform.
        -:  793: */
        -:  794:#define __USE_MINGW_FSEEK
        -:  795:#endif
        -:  796:
        -:  797:#ifdef __USE_MINGW_FSEEK
        -:  798:/* Regardless of how it may have become defined, when __USE_MINGW_FSEEK has
        -:  799: * been defined, we must redirect calls to fseek() and fwrite(), so that the
        -:  800: * Win9x zero padding limitation can be mitigated.
        -:  801: */
        -:  802:__cdecl __MINGW_NOTHROW  int __mingw_fseek (FILE *, __off64_t, int);
        -:  803:__CRT_ALIAS int fseek( FILE *__fp, long __offset, int __whence )
        -:  804:{ return __mingw_fseek( __fp, (__off64_t)(__offset), __whence ); }
        -:  805:
        -:  806:__cdecl __MINGW_NOTHROW  size_t __mingw_fwrite (const void *, size_t, size_t, FILE *);
        -:  807:__CRT_ALIAS size_t fwrite( const void *__buf, size_t __len, size_t __cnt, FILE *__fp )
        -:  808:{ return __mingw_fwrite( __buf, __len, __cnt, __fp ); }
        -:  809:#endif /* __USE_MINGW_FSEEK */
        -:  810:
        -:  811:/* An opaque data type used for storing file positions...  The contents
        -:  812: * of this type are unknown, but we (the compiler) need to know the size
        -:  813: * because the programmer using fgetpos and fsetpos will be setting aside
        -:  814: * storage for fpos_t aggregates.  Actually I tested using a byte array and
        -:  815: * it is fairly evident that fpos_t is a 32-bit type in CRTDLL.DLL, but in
        -:  816: * MSVCRT.DLL, it is a 64-bit type.  Define it in terms of an int type of
        -:  817: * the appropriate size, encapsulated within an aggregate type, to make
        -:  818: * it opaque to casting, and so discourage abuse.
        -:  819: */
        -:  820:#ifdef __MSVCRT__
        -:  821:typedef union { __int64 __value; __off64_t __offset; } fpos_t;
        -:  822:#else
        -:  823:typedef union { __int32 __value; __off32_t __offset; } fpos_t;
        -:  824:#endif
        -:  825:
        -:  826:_CRTIMP __cdecl __MINGW_NOTHROW  int fgetpos (FILE *, fpos_t *);
        -:  827:_CRTIMP __cdecl __MINGW_NOTHROW  int fsetpos (FILE *, const fpos_t *);
        -:  828:
        -:  829:#if _WIN32_WINNT >= _WIN32_WINNT_VISTA || __MSVCRT_VERSION__ >= __MSVCR80_DLL
        -:  830: /* Microsoft introduced a number of variations on fseek() and ftell(),
        -:  831:  * beginning with MSVCR80.DLL; the bare _fseeki64() and _ftelli64() were
        -:  832:  * subsequently integrated into MSVCRT.DLL, from Vista onward...
        -:  833:  */
        -:  834:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fseeki64 (FILE *, __int64, int);
        -:  835:_CRTIMP __cdecl __MINGW_NOTHROW __int64 _ftelli64 (FILE *);
        -:  836:
        -:  837:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL
        -:  838: /* ...while the "nolock" variants remain exclusive to MSVCR80.DLL, and
        -:  839:  * its later MSVC specific derivatives.
        -:  840:  */
        -:  841:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fseek_nolock (FILE *, long, int);
        -:  842:_CRTIMP __cdecl __MINGW_NOTHROW  long   _ftell_nolock (FILE *);
        -:  843:
        -:  844:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fseeki64_nolock (FILE *, __int64, int);
        -:  845:_CRTIMP __cdecl __MINGW_NOTHROW __int64 _ftelli64_nolock (FILE *);
        -:  846:
        -:  847:#endif  /* MSVCR80.DLL and later derivatives ONLY */
        -:  848:
        -:  849:#else	/* pre-MSVCR80.DLL or MSVCRT.DLL pre-Vista */
        -:  850:/* The Microsoft DLLs don't provide either _fseeki64() or _ftelli64(), but
        -:  851: * they DO provide fgetpos(), fsetpos(), and _lseeki64(), which may be used
        -:  852: * to emulate the two missing functions.  (Note that we choose to provide
        -:  853: * these emulations in the form of MinGW external helper functions, rather
        -:  854: * than pollute the <stdio.h> namespace with declarations, such as that
        -:  855: * for _lseeki64(), which properly belongs in <io.h>).
        -:  856: */
        -:  857:#ifndef __USE_MINGW_FSEEK
        -:  858:/* If this option has been selected, an alternative emulation for _fseeki64()
        -:  859: * is provided later, to ensure that the call is wrapped in a MinGW specific
        -:  860: * fseek() handling API.
        -:  861: */
        -:  862:int __cdecl __MINGW_NOTHROW __mingw_fseeki64 (FILE *, __int64, int);
        -:  863:__CRT_ALIAS __cdecl __MINGW_NOTHROW  int _fseeki64 (FILE *__f, __int64 __o, int __w)
        -:  864:{ return __mingw_fseeki64 (__f, __o, __w); }
        -:  865:#endif
        -:  866:
        -:  867:__int64 __cdecl __MINGW_NOTHROW __mingw_ftelli64 (FILE *);
        -:  868:__CRT_ALIAS __cdecl  __int64 __MINGW_NOTHROW _ftelli64 (FILE *__file )
        -:  869:{ return __mingw_ftelli64 (__file); }
        -:  870:
        -:  871:#endif	/* pre-MSVCR80.DLL or MSVCRT.DLL pre-Vista */
        -:  872:
        -:  873:/* Error Functions
        -:  874: */
        -:  875:_CRTIMP __cdecl __MINGW_NOTHROW  int feof (FILE *);
        -:  876:_CRTIMP __cdecl __MINGW_NOTHROW  int ferror (FILE *);
        -:  877:
        -:  878:#ifdef __cplusplus
        -:  879:inline __cdecl __MINGW_NOTHROW  int feof (FILE * __F){ return __F->_flag & _IOEOF; }
        -:  880:inline __cdecl __MINGW_NOTHROW  int ferror (FILE * __F){ return __F->_flag & _IOERR; }
        -:  881:#else
        -:  882:#define feof(__F)     ((__F)->_flag & _IOEOF)
        -:  883:#define ferror(__F)   ((__F)->_flag & _IOERR)
        -:  884:#endif
        -:  885:
        -:  886:_CRTIMP __cdecl __MINGW_NOTHROW  void clearerr (FILE *);
        -:  887:_CRTIMP __cdecl __MINGW_NOTHROW  void perror (const char *);
        -:  888:
        -:  889:#ifndef __STRICT_ANSI__
        -:  890:/*
        -:  891: * Pipes
        -:  892: */
        -:  893:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * _popen (const char *, const char *);
        -:  894:_CRTIMP __cdecl __MINGW_NOTHROW  int    _pclose (FILE *);
        -:  895:
        -:  896:#ifndef NO_OLDNAMES
        -:  897:_CRTIMP __cdecl __MINGW_NOTHROW  FILE *  popen (const char *, const char *);
        -:  898:_CRTIMP __cdecl __MINGW_NOTHROW  int     pclose (FILE *);
        -:  899:#endif
        -:  900:
        -:  901:/* Other Non ANSI functions
        -:  902: */
        -:  903:_CRTIMP __cdecl __MINGW_NOTHROW  int    _flushall (void);
        -:  904:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fgetchar (void);
        -:  905:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fputchar (int);
        -:  906:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * _fdopen (int, const char *);
        -:  907:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fileno (FILE *);
        -:  908:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fcloseall (void);
        -:  909:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * _fsopen (const char *, const char *, int);
        -:  910:#ifdef __MSVCRT__
        -:  911:_CRTIMP __cdecl __MINGW_NOTHROW  int    _getmaxstdio (void);
        -:  912:_CRTIMP __cdecl __MINGW_NOTHROW  int    _setmaxstdio (int);
        -:  913:#endif
        -:  914:
        -:  915:/* Microsoft introduced a capability in MSVCR80.DLL and later, to
        -:  916: * set the minimum number of digits to be displayed in a printf()
        -:  917: * floating point exponent; they retro-fitted this in MSVCRT.DLL,
        -:  918: * from Windows-Vista onwards, but we provide our own wrappers in
        -:  919: * libmingwex.a, which make it possible for us to emulate the API
        -:  920: * for any version of MSVCRT.DLL (including WinXP and earlier).
        -:  921: */
        -:  922:#define _TWO_DIGIT_EXPONENT    1
        -:  923:
        -:  924:/* While Microsoft define the preceding manifest constant, they
        -:  925: * appear to neglect to define its complement, (for restoration
        -:  926: * of their default exponent display format); for orthogonality,
        -:  927: * we will provide this regardless of Microsoft's negligence.
        -:  928: */
        -:  929:#define _THREE_DIGIT_EXPONENT  0
        -:  930:
        -:  931:/* Once again, unspecified by Microsoft, (and mostly redundant),
        -:  932: * it is convenient to specify a combining mask for these.
        -:  933: */
        -:  934:#define _EXPONENT_DIGIT_MASK  (_TWO_DIGIT_EXPONENT | _THREE_DIGIT_EXPONENT)
        -:  935:
        -:  936:unsigned int __cdecl __mingw_get_output_format (void);
        -:  937:unsigned int __cdecl __mingw_set_output_format (unsigned int);
        -:  938:
        -:  939:/* Also appearing for the first time in MSVCR80.DLL, and then also
        -:  940: * retro-fitted to MSVCRT.DLL from Windows-Vista onwards, was this
        -:  941: * pair of functions to control availability of "%n" formatting in
        -:  942: * the MSVCRT.DLL printf() family of functions, for which we also
        -:  943: * provide our own DLL version agnostic wrappers:
        -:  944: */
        -:  945:int __cdecl __mingw_get_printf_count_output (void);
        -:  946:int __cdecl __mingw_set_printf_count_output (int);
        -:  947:
        -:  948:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL
        -:  949:/* When the user declares that MSVCR80.DLL features are supported,
        -:  950: * we simply expose the corresponding APIs...
        -:  951: */
        -:  952:_CRTIMP unsigned int __cdecl __MINGW_NOTHROW _get_output_format (void);
        -:  953:_CRTIMP unsigned int __cdecl __MINGW_NOTHROW _set_output_format (unsigned int);
        -:  954:
        -:  955:_CRTIMP __cdecl __MINGW_NOTHROW  int _get_printf_count_output (void);
        -:  956:_CRTIMP __cdecl __MINGW_NOTHROW  int _set_printf_count_output (int);
        -:  957:
        -:  958:#else
        -:  959:/* ...otherwise, we emulate the APIs, in a DLL version agnostic
        -:  960: * manner, using our own implementation wrappers.
        -:  961: */
        -:  962:__CRT_ALIAS unsigned int __cdecl _get_output_format (void)
        -:  963:{ return __mingw_get_output_format (); }
        -:  964:
        -:  965:__CRT_ALIAS unsigned int __cdecl _set_output_format (unsigned int __style)
        -:  966:{ return __mingw_set_output_format (__style); }
        -:  967:
        -:  968:/* When using our own printf() implementation, "%n" format is ALWAYS
        -:  969: * supported, so we make this API a no-op, reporting it to be so; for
        -:  970: * the alternative case, when using MSVCRT.DLL's printf(), we delegate
        -:  971: * to our wrapper API implementation, which will invoke the API function
        -:  972: * calls within the DLL, if they are available, or persistently report
        -:  973: * the state of "%n" formatting as DISABLED if they are not.
        -:  974: */
        -:  975:#if __USE_MINGW_ANSI_STDIO
        -:  976:/* Note that __USE_MINGW_ANSI_STDIO is not guaranteed to resolve to any
        -:  977: * symbol which will represent a compilable logic state; map it to this
        -:  978: * alternative which will, for the true state...
        -:  979: */
        -:  980:# define __USE_MINGW_PRINTF  1
        -:  981:#else
        -:  982:/* ...and for the false.
        -:  983: */
        -:  984:# define __USE_MINGW_PRINTF  0
        -:  985:#endif
        -:  986:
        -:  987:__CRT_ALIAS int __cdecl _get_printf_count_output (void)
        -:  988:{ return __USE_MINGW_PRINTF ? 1 : __mingw_get_printf_count_output (); }
        -:  989:
        -:  990:__CRT_ALIAS int __cdecl _set_printf_count_output (int __mode)
        -:  991:{ return __USE_MINGW_PRINTF ? 1 : __mingw_set_printf_count_output (__mode); }
        -:  992:#endif
        -:  993:
        -:  994:#ifndef _NO_OLDNAMES
        -:  995:_CRTIMP __cdecl __MINGW_NOTHROW  int    fgetchar (void);
        -:  996:_CRTIMP __cdecl __MINGW_NOTHROW  int    fputchar (int);
        -:  997:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * fdopen (int, const char *);
        -:  998:_CRTIMP __cdecl __MINGW_NOTHROW  int    fileno (FILE *);
        -:  999:#endif	/* !_NO_OLDNAMES */
        -: 1000:
        -: 1001:#define _fileno(__F) ((__F)->_file)
        -: 1002:#ifndef _NO_OLDNAMES
        -: 1003:#define fileno(__F) ((__F)->_file)
        -: 1004:#endif
        -: 1005:
        -: 1006:#if defined (__MSVCRT__) && ! defined (__NO_MINGW_LFS)
        -: 1007:__CRT_ALIAS FILE * __cdecl __MINGW_NOTHROW  fopen64 (const char *, const char *);
        -: 1008:__CRT_ALIAS __JMPSTUB__(( FUNCTION = fopen64, REMAPPED = fopen ))
        -: 1009:FILE * __cdecl __MINGW_NOTHROW  fopen64 (const char * filename, const char * mode)
        -: 1010:{ return fopen (filename, mode); }
        -: 1011:
        -: 1012:int __cdecl __MINGW_NOTHROW  fseeko64 (FILE *, __off64_t, int);
        -: 1013:
        -: 1014:#ifdef __USE_MINGW_FSEEK
        -: 1015:/* When this option is selected, we need to redirect calls to _fseeki64()
        -: 1016: * and fseeko64() through a MinGW specific wrapper.  Since the two functions
        -: 1017: * are fundamentally identical, differing only in the type of the "offset"
        -: 1018: * argument, (and both types are effectively 64-bit signed ints anyway),
        -: 1019: * the same wrapper will suffice for both.
        -: 1020: */
        -: 1021:__CRT_ALIAS int _fseeki64( FILE *__fp, __int64 __offset, int __whence )
        -: 1022:{ return __mingw_fseek( __fp, (__off64_t)(__offset), __whence ); }
        -: 1023:
        -: 1024:__CRT_ALIAS int fseeko64( FILE *__fp, __off64_t __offset, int __whence )
        -: 1025:{ return __mingw_fseek( __fp, __offset, __whence ); }
        -: 1026:#endif
        -: 1027:
        -: 1028:__off64_t __cdecl __MINGW_NOTHROW ftello64 (FILE *);
        -: 1029:
        -: 1030:#endif	/* __MSVCRT__ && !__NO_MINGW_LFS */
        -: 1031:#endif	/* !__STRICT_ANSI__ */
        -: 1032:#endif	/* _STDIO_H */
        -: 1033:
        -: 1034:#if ! (defined _STDIO_H && defined _WCHAR_H)
        -: 1035:/* The following are declared when including either <stdio.h> or <wchar.h>.
        -: 1036: * If both header include guards are now in place, then we must currently be
        -: 1037: * including <stdio.h> in its own right, having already processed this block
        -: 1038: * during prior partial inclusion by <wchar.h>; there is no need to process
        -: 1039: * it a second time.
        -: 1040: */
        -: 1041:_CRTIMP __cdecl __MINGW_NOTHROW  int     fwprintf (FILE *, const wchar_t *, ...);
        -: 1042:_CRTIMP __cdecl __MINGW_NOTHROW  int     wprintf (const wchar_t *, ...);
        -: 1043:_CRTIMP __cdecl __MINGW_NOTHROW  int     vfwprintf (FILE *, const wchar_t *, __VALIST);
        -: 1044:_CRTIMP __cdecl __MINGW_NOTHROW  int     vwprintf (const wchar_t *, __VALIST);
        -: 1045:_CRTIMP __cdecl __MINGW_NOTHROW  int    _snwprintf (wchar_t *, size_t, const wchar_t *, ...);
        -: 1046:_CRTIMP __cdecl __MINGW_NOTHROW  int    _vscwprintf (const wchar_t *, __VALIST);
        -: 1047:_CRTIMP __cdecl __MINGW_NOTHROW  int    _vsnwprintf (wchar_t *, size_t, const wchar_t *, __VALIST);
        -: 1048:_CRTIMP __cdecl __MINGW_NOTHROW  int     fwscanf (FILE *, const wchar_t *, ...);
        -: 1049:_CRTIMP __cdecl __MINGW_NOTHROW  int     wscanf (const wchar_t *, ...);
        -: 1050:_CRTIMP __cdecl __MINGW_NOTHROW  int     swscanf (const wchar_t *, const wchar_t *, ...);
        -: 1051:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fgetwc (FILE *);
        -: 1052:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fputwc (wchar_t, FILE *);
        -: 1053:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  ungetwc (wchar_t, FILE *);
        -: 1054:
        -: 1055:#ifndef __STRICT_ANSI__
        -: 1056:/* These differ from the ISO C prototypes, which have a maxlen parameter (like snprintf).
        -: 1057: */
        -: 1058:_CRTIMP __cdecl __MINGW_NOTHROW  int  swprintf (wchar_t *, const wchar_t *, ...);
        -: 1059:_CRTIMP __cdecl __MINGW_NOTHROW  int  vswprintf (wchar_t *, const wchar_t *, __VALIST);
        -: 1060:#endif
        -: 1061:
        -: 1062:#ifdef __MSVCRT__
        -: 1063:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * fgetws (wchar_t *, int, FILE *);
        -: 1064:_CRTIMP __cdecl __MINGW_NOTHROW  int       fputws (const wchar_t *, FILE *);
        -: 1065:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    getwc (FILE *);
        -: 1066:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    getwchar (void);
        -: 1067:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    putwc (wint_t, FILE *);
        -: 1068:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    putwchar (wint_t);
        -: 1069:
        -: 1070:#ifndef __STRICT_ANSI__
        -: 1071:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * _getws (wchar_t *);
        -: 1072:_CRTIMP __cdecl __MINGW_NOTHROW  int       _putws (const wchar_t *);
        -: 1073:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfdopen(int, const wchar_t *);
        -: 1074:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfopen (const wchar_t *, const wchar_t *);
        -: 1075:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfreopen (const wchar_t *, const wchar_t *, FILE *);
        -: 1076:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfsopen (const wchar_t *, const wchar_t *, int);
        -: 1077:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * _wtmpnam (wchar_t *);
        -: 1078:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * _wtempnam (const wchar_t *, const wchar_t *);
        -: 1079:_CRTIMP __cdecl __MINGW_NOTHROW  int       _wrename (const wchar_t *, const wchar_t *);
        -: 1080:_CRTIMP __cdecl __MINGW_NOTHROW  int       _wremove (const wchar_t *);
        -: 1081:_CRTIMP __cdecl __MINGW_NOTHROW  void      _wperror (const wchar_t *);
        -: 1082:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wpopen (const wchar_t *, const wchar_t *);
        -: 1083:
        -: 1084:#endif  /* !__STRICT_ANSI__ */
        -: 1085:#endif	/* __MSVCRT__ */
        -: 1086:
        -: 1087:#ifdef _ISOC99_SOURCE
        -: 1088:__JMPSTUB__(( FUNCTION = snwprintf, DLLENTRY = _snwprintf ))
        -: 1089:__cdecl __MINGW_NOTHROW  int snwprintf (wchar_t *, size_t, const wchar_t *, ...);
        -: 1090:__cdecl __MINGW_NOTHROW  int vsnwprintf (wchar_t *, size_t, const wchar_t *, __VALIST);
        -: 1091:
        -: 1092:#ifndef __NO_INLINE__
        -: 1093:__CRT_INLINE __cdecl __MINGW_NOTHROW
        -: 1094:__JMPSTUB__(( FUNCTION = vsnwprintf, DLLENTRY = _vsnwprintf ))
        -: 1095:int vsnwprintf (wchar_t *__s, size_t __n, const wchar_t *__fmt, __VALIST __arg)
        -: 1096:{ return _vsnwprintf ( __s, __n, __fmt, __arg); }
        -: 1097:#endif
        -: 1098:
        -: 1099:__cdecl __MINGW_NOTHROW  int  vwscanf (const wchar_t *__restrict__, __VALIST);
        -: 1100:__cdecl __MINGW_NOTHROW
        -: 1101:int  vfwscanf (FILE *__restrict__, const wchar_t *__restrict__, __VALIST);
        -: 1102:__cdecl __MINGW_NOTHROW
        -: 1103:int  vswscanf (const wchar_t *__restrict__, const wchar_t * __restrict__, __VALIST);
        -: 1104:
        -: 1105:#endif  /* _ISOC99_SOURCE */
        -: 1106:#endif  /* ! (_STDIO_H && _WCHAR_H) */
        -: 1107:
        -: 1108:#if defined _STDIO_H && ! defined __STRICT_ANSI__
        -: 1109:#if defined __MSVCRT__ && ! defined _NO_OLDNAMES
        -: 1110:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * wpopen (const wchar_t *, const wchar_t *);
        -: 1111:#endif
        -: 1112:
        -: 1113:/* Other non-ANSI wide character functions...
        -: 1114: */
        -: 1115:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t _fgetwchar (void);
        -: 1116:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t _fputwchar (wint_t);
        -: 1117:_CRTIMP __cdecl __MINGW_NOTHROW  int    _getw (FILE *);
        -: 1118:_CRTIMP __cdecl __MINGW_NOTHROW  int    _putw (int, FILE *);
        -: 1119:
        -: 1120:#ifndef _NO_OLDNAMES
        -: 1121:/* ...and their original names, before Microsoft uglification...
        -: 1122: */
        -: 1123:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fgetwchar (void);
        -: 1124:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fputwchar (wint_t);
        -: 1125:_CRTIMP __cdecl __MINGW_NOTHROW  int     getw (FILE *);
        -: 1126:_CRTIMP __cdecl __MINGW_NOTHROW  int     putw (int, FILE *);
        -: 1127:
        -: 1128:#endif  /* !_NO_OLDNAMES */
        -: 1129:#endif  /* !__STRICT_ANSI__ */
        -: 1130:
        -: 1131:_END_C_DECLS
        -: 1132:
        -: 1133:#endif	/* ! RC_INVOKED */
        -: 1134:#endif  /* !_STDIO_H: $RCSfile: stdio.h,v $: end of file */
